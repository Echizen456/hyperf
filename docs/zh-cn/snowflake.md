# Snowflake
##Algorithm Introduction
`Snowflake 'is a distributed global unique ID generation algorithm proposed by twitter. The result of ID generation by the algorithm is a long integer with the size of 64bit. Under the standard algorithm, its structure is as follows:
![snowflake](imgs/ snowflake.jpeg )
-One bit, no need.
-The highest bit in the binary system is the sign bit. The 'ID' generated by us is generally a positive integer, so the highest bit is fixed to 0.
-The '41 bit' is used to record the timestamp (MS).
-'41 bits' can represent' 2 ^ 41 - 1 'numbers.
-In other words, the "41 bit" can represent the value of '2 ^ 41 - 1' milliseconds, and the unit year is' (2 ^ 41 - 1) / (1000 * 60 * 60 * 24 * 365) "about '69' years.
-"10 bits", used to record the "Id" of the working machine.
-It can be deployed in '2 ^ 10' nodes, including '5' data centerid 'and' 5 'worker ID'.
-A '12 bit' serial number is used to record different 'ID' generated in the same millisecond.
-The maximum positive integer that a '12 digit' can represent is' 2 ^ 12 - 1 'with a total of' 4095 'numbers to represent the' 4095 'ID' serial numbers generated by the same machine in the same time interval (MS).
`Snowflake 'guarantees:
-All generated 'IDS' increase with time trend.
-There will be no duplicate 'ID' in the whole distributed system (because there are 'datacenter ID (5 bits)' and 'workerid (5 bits)' to distinguish them.
[hyperf / snowflake] of hyperf（ https://github.com/hyperf/snowflake ）Component provides good extensibility in design, allowing you to implement other variant algorithms based on snowflake with simple extension.
##Installation
` ` ` `
composer require hyperf/snowflake
` ` ` `
##Use
The framework provides' metageneratorinterface 'and' idgeneratorinterface '. Metageneratorinterface' generates' meta 'files of' ID ', and' idgeneratorinterface 'generates' distributed ID' based on the corresponding 'meta' files.
The 'metagenerator interface' used by the framework by default is a 'millisecond level generator' based on 'redis'.
The configuration file is located in ` config / autoload/ snowflake.php `If the configuration file does not exist, you can execute the/ hyperf.php  vendor:publish hyperf/snowflake `Command to create a default configuration. The contents of the configuration file are as follows:
```php
<?php
declare(strict_ types=1);
use Hyperf\Snowflake\MetaGenerator\RedisMilliSecondMetaGenerator;
use Hyperf\Snowflake\MetaGenerator\RedisSecondMetaGenerator;
use Hyperf\Snowflake\MetaGeneratorInterface;
return [
'begin_ second' => MetaGeneratorInterface::DEFAULT_ BEGIN_ SECOND,
RedisMilliSecondMetaGenerator::class => [
// Redis Pool
'pool' => 'default',
//The key used to calculate the workerid
'key' => RedisMilliSecondMetaGenerator::DEFAULT_ REDIS_ KEY
]
RedisSecondMetaGenerator::class => [
// Redis Pool
'pool' => 'default',
//The key used to calculate the workerid
'key' => RedisMilliSecondMetaGenerator::DEFAULT_ REDIS_ KEY
]
];
` ` ` `
Using 'snowflake' in the framework is very simple. You just need to take out the 'idgeneratorinterface' object from 'Di'.
```php
<?php
use Hyperf\Snowflake\IdGeneratorInterface;
use Hyperf\Utils\ApplicationContext;
$container = ApplicationContext::getContainer();
$generator = $container->get(IdGeneratorInterface::class);
$id = $generator->generate();
` ` ` `
When you know that the 'ID' needs to reverse the corresponding 'meta', you just need to call 'generate'.
```php
<?php
use Hyperf\Snowflake\IdGeneratorInterface;
use Hyperf\Utils\ApplicationContext;
$container = ApplicationContext::getContainer();
$generator = $container->get(IdGeneratorInterface::class);
$meta = $generator->degenerate($id);
` ` ` `
##Override 'meta' generator
`There are many ways to implement the distributed global unique ID, and there are also many variants based on the snowflake algorithm. Although they are all snowflake algorithms, they are not the same. For example, someone may generate a 'meta' based on 'userid' rather than 'workerid'. Next, let's implement a simple 'metagenerator'.
In short, the 'userid' will definitely exceed '10 bits'. Therefore, the default' datacenterid 'and' workerid 'cannot be installed. Therefore, the' userid 'module needs to be taken.
```php
<?php
declare(strict_ types=1);
use Hyperf\Snowflake\IdGenerator;
class UserDefinedIdGenerator
{
* *
* @var IdGenerator\SnowflakeIdGenerator
* /
protected $idGenerator;
public function __ construct(IdGenerator\SnowflakeIdGenerator $idGenerator)
{
$this->idGenerator = $idGenerator;
}
public function generate(int $userId)
{
$meta = $this->idGenerator->getMetaGenerator()->generate();
return $this->idGenerator->generate($meta->setWorkerId($userId % 31));
}
public function degenerate(int $id)
{
return $this->idGenerator->degenerate($id);
}
}
use Hyperf\Utils\ApplicationContext;
$container = ApplicationContext::getContainer();
$generator = $container->get(UserDefinedIdGenerator::class);
$userId = 20190620;
$id = $generator->generate($userId);
` ` ` `
##Application in database model
After configuring snowflake, we can make the database model directly use snowflake ID as the primary key.
```php
<?php
class User extends \Hyperf\Database\Model\Model {
